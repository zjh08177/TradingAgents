#!/usr/bin/env python3
"""
Automated validation loop that repeatedly runs debug_local.sh until zero errors.
Implements fixes automatically where possible.
Maximum 3 iterations before giving up.
"""

import subprocess
import time
import re
import os
import sys
from datetime import datetime
from pathlib import Path


class ValidationLoop:
    """Automated validation loop for debug script."""
    
    def __init__(self, max_iterations=3):
        self.max_iterations = max_iterations
        self.iteration_count = 0
        self.log_file = f"validation_loop_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
        
    def log(self, message):
        """Log message to file and console."""
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        log_entry = f"[{timestamp}] {message}"
        print(log_entry)
        with open(self.log_file, 'a') as f:
            f.write(log_entry + '\n')
    
    def run_debug_script(self):
        """Run debug_local.sh and capture output."""
        self.log("üîÑ Running debug_local.sh...")
        
        try:
            result = subprocess.run(
                ['./debug_local.sh'],
                capture_output=True,
                text=True,
                timeout=720  # Respect the 720s timeout
            )
            
            return result.returncode, result.stdout, result.stderr
            
        except subprocess.TimeoutExpired:
            self.log("‚ùå Debug script timed out after 720 seconds")
            return -1, "", "Timeout"
        except Exception as e:
            self.log(f"‚ùå Error running debug script: {e}")
            return -1, "", str(e)
    
    def analyze_output(self, stdout, stderr):
        """Analyze output for errors and warnings."""
        combined_output = stdout + stderr
        
        errors = []
        warnings = []
        
        # Error patterns
        error_patterns = [
            (r"Error:", "General error"),
            (r"‚ùå", "Failed check"),
            (r"failed", "Failure"),
            (r"Traceback", "Python traceback"),
            (r"Exception", "Exception"),
            (r"ImportError", "Import error"),
            (r"ModuleNotFoundError", "Module not found"),
            (r"SyntaxError", "Syntax error"),
            (r"TypeError", "Type error"),
            (r"AttributeError", "Attribute error"),
            (r"ValueError", "Value error"),
        ]
        
        # Warning patterns  
        warning_patterns = [
            (r"WARNING", "Warning"),
            (r"‚ö†Ô∏è", "Warning symbol"),
            (r"warning", "Warning (lowercase)"),
            (r"fallback", "Fallback logic"),
            (r"insufficient", "Insufficient data"),
            (r"missing data", "Missing data"),
            (r"empty", "Empty data"),
        ]
        
        # Count errors
        for pattern, description in error_patterns:
            matches = re.findall(pattern, combined_output, re.IGNORECASE)
            if matches:
                errors.append({
                    'pattern': pattern,
                    'description': description,
                    'count': len(matches)
                })
        
        # Count warnings
        for pattern, description in warning_patterns:
            matches = re.findall(pattern, combined_output, re.IGNORECASE)
            if matches:
                warnings.append({
                    'pattern': pattern,
                    'description': description,
                    'count': len(matches)
                })
        
        return errors, warnings
    
    def apply_fixes(self, errors, warnings):
        """Apply automated fixes for known issues."""
        fixes_applied = []
        
        # Fix 1: Missing .env file
        if any('environment variable' in str(e) for e in errors):
            if not os.path.exists('.env'):
                self.log("üîß Creating .env file with dummy values...")
                with open('.env', 'w') as f:
                    f.write("# Auto-generated by validation loop\n")
                    f.write("OPENAI_API_KEY=sk-dummy-key-for-testing\n")
                    f.write("LANGCHAIN_TRACING_V2=false\n")
                fixes_applied.append("Created .env file")
        
        # Fix 2: Import errors - install missing packages
        import_errors = [e for e in errors if 'ImportError' in e.get('description', '')]
        if import_errors:
            self.log("üîß Installing missing packages...")
            subprocess.run(['pip', 'install', '-q', '-e', '.'], check=False)
            fixes_applied.append("Reinstalled packages")
        
        # Fix 3: Directory issues
        if any('not found' in str(e) for e in errors):
            # Ensure log directory exists
            os.makedirs('debug_logs', exist_ok=True)
            fixes_applied.append("Created debug_logs directory")
        
        return fixes_applied
    
    def run_validation_loop(self):
        """Main validation loop."""
        self.log("üöÄ Starting validation loop")
        self.log(f"üìã Max iterations: {self.max_iterations}")
        self.log(f"üìù Log file: {self.log_file}")
        
        while self.iteration_count < self.max_iterations:
            self.iteration_count += 1
            self.log(f"\n{'='*60}")
            self.log(f"üîÑ Iteration {self.iteration_count}/{self.max_iterations}")
            self.log(f"{'='*60}")
            
            # Run debug script
            return_code, stdout, stderr = self.run_debug_script()
            
            if return_code == -1:
                self.log("‚ùå Debug script failed to run properly")
                continue
            
            # Analyze output
            errors, warnings = self.analyze_output(stdout, stderr)
            
            total_errors = sum(e['count'] for e in errors)
            total_warnings = sum(w['count'] for w in warnings)
            
            self.log(f"\nüìä Analysis Results:")
            self.log(f"   ‚ùå Total errors: {total_errors}")
            self.log(f"   ‚ö†Ô∏è  Total warnings: {total_warnings}")
            
            # Check if we're done
            if total_errors == 0 and total_warnings == 0:
                self.log("\n‚úÖ SUCCESS: Zero errors and zero warnings!")
                self.log(f"üéâ Validation completed successfully after {self.iteration_count} iteration(s)")
                return True
            
            # Log detailed findings
            if errors:
                self.log("\n‚ùå Errors found:")
                for error in errors:
                    self.log(f"   - {error['description']}: {error['count']} occurrences")
            
            if warnings:
                self.log("\n‚ö†Ô∏è  Warnings found:")
                for warning in warnings:
                    self.log(f"   - {warning['description']}: {warning['count']} occurrences")
            
            # Apply fixes
            if self.iteration_count < self.max_iterations:
                self.log("\nüîß Attempting to apply fixes...")
                fixes = self.apply_fixes(errors, warnings)
                
                if fixes:
                    self.log(f"‚úÖ Applied {len(fixes)} fix(es):")
                    for fix in fixes:
                        self.log(f"   - {fix}")
                else:
                    self.log("‚ö†Ô∏è  No automated fixes available")
                
                # Wait before next iteration
                self.log("‚è≥ Waiting 2 seconds before next iteration...")
                time.sleep(2)
        
        # Failed after max iterations
        self.log(f"\n‚ùå FAILED: Still have errors/warnings after {self.max_iterations} iterations")
        self.log("\nüìã Summary of unresolved issues:")
        
        if errors:
            self.log("\n‚ùå Persistent errors:")
            for error in errors:
                self.log(f"   - {error['description']}: {error['count']} occurrences")
        
        if warnings:
            self.log("\n‚ö†Ô∏è  Persistent warnings:")
            for warning in warnings:
                self.log(f"   - {warning['description']}: {warning['count']} occurrences")
        
        self.log("\nüí° Manual intervention required to fix remaining issues")
        
        return False


def main():
    """Main entry point."""
    print("ü§ñ Automated Validation Loop for debug_local.sh")
    print("=" * 60)
    
    # Check if debug_local.sh exists
    if not os.path.exists('./debug_local.sh'):
        print("‚ùå Error: debug_local.sh not found in current directory")
        sys.exit(1)
    
    # Make sure it's executable
    os.chmod('./debug_local.sh', 0o755)
    
    # Run validation loop
    validator = ValidationLoop(max_iterations=3)
    success = validator.run_validation_loop()
    
    # Exit with appropriate code
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()